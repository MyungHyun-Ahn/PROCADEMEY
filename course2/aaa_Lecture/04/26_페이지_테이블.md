# 페이지 테이블
### 메모리 테이블의 구조
가상 메모리 테이블
* 엔트리
  * Process 페이지가 참조
  * 메모리 프레임을 참조

Process 페이지 테이블
* 페이지 크기는 4MB

Frame
* 물리 메모리 프레임

메모리 테이블의 구조
* 엔트리 하나의 크기
  * 32bit - 4 bytes
  * 64bit - 8 bytes
* 가상 메모리 테이블이 4MB 용량이 되야함(너무 낭비)
* 가상 주소를 인덱스로 해서 메모리 테이블을 참조하면 프레임이 나옴
  * 메모리를 여러 단계로 나누어서 낭비를 줄이자!

### 가상 메모리 테이블 해석

가상 메모리 테이블을 해석하는 것
* 하드웨어 장치임 x86
  * 컨텍스트 스위칭마다 교체

주소 0x00000000
* 상위 20비트를 Index로 활용
  * 10비트 : PDE - Page Directory Entry
    * 큰 카테고리
  * 10비트 : PTE - Page Table Entry
    * 하위 카테고리
* 나머지 비트는 offset으로 활용

가상 메모리 테이블은 커널 메모리에 존재함

CR 레지스터
* CR3 레지스터 PDE 포인터를 가리킨다.
* MMU가 하는 일은 CR3를 참조하여 프레임 주소를 찾아 offset 비트를 통해 접근

PDE는 프로세스 별로 생성됨

커널 테이블 엔트리의 PTE는 모두 같은 것을 가리킨다.
  * 커널 공간은 모두 같은 것

여기까지는 Vista 이전

### 메모리 참조 오류
* PDE가 없거나
* PDE를 타고 갔는데 PTE가 없는 것
  * 할당 안한 것 - 메모리 뷰 ???

### x86 시스템에서 물리 메모리를 더 쓰고 싶다면
확장버전 PAE
* CR3 -> 2bit -> PDE -> PTE
* 물리 프레임 64기가까지 활용 가능
* 현 기본 32bit 시스템에서는 이것을 사용
  * Vista 이후

2bit
* 00, 01 : 유저 영역
* 10, 11 : 커널 영역 -> 공용

0x00000000
* 2bit, 9bit, 9bit, 12bit
* 로 나눠쓴다.

### x64 버전

주소 - 64비트 중 하위 48비트만 사용
* 9, 9, 9, 9, 나머지 offset
* 4단계로 나누어 사용

CR3 레지스터만 컨텍스트 스위칭마다 교체

### 주소 변환 버퍼
TLB (Translate Lookup Buffer)
* PTE안의 엔트리 몇 개를 저장
* TLB에 없다면 CR3 부터 순차적으로 탐색
* 캐시랑 비슷한 구조
* 인텔 11세대에서 1024개 정도 저장
* 페이지 주소가 저장되어 있음

멜트 다운 스팩터
* 캐시의 커널 메모리의 잔재를 획득하는 것
* 그래서 커널모드로 전환이 될때마다 FLUSH 하여 해결
  * 성능은 떨어짐

### 가상 메모리 쓰기
Reserve
* 물리 메모리 매핑 이전
* 페이지 엔트리 생성 X
* 프로세스에서만 예약

Commit
* 물리 메모리 매핑과 PTE 세팅은 직접쓸 때 만듬

Reserve 하는 이유
* reserve는 64KB 단위로 가능
  * 4KB로 떨어지는 주소부터 시작
* 모든 reserve 주소가 하위 16비트는 비어있음
  * 연속적인 가상 메모리가 필요하면 예약해두어야 함
  * ex) Stack 메모리

스택 Default 1MB Reserve
* 1MB 상단 Reserve
* 여기에 참조하면 스택 오버 플로우

Release -> Commit을 해도 PTE에 할당 안함
* 지연 처리 - 쓰는 순간에 할당

### VAD (Virtual Address Descriptor)
VAD
* AVL 트리로 구현
* 주소 대역의 정보를 관리
* 속성이 연속된 Reserve, Free, Commit 대역으로 찾는다.

주된 목적
* VirtualAlloc을 할 때
* 매개변수로 ptr을 안 넣는 방법일 때 사용
* 알아서 빈 영역에 할당
* VAD로 찾아와서 할당하는 것

예약을 걸면 VAD에 어디 ~ 어디 영역까지 Reserve라고 기록
* 첫 커밋도 마찬가지

### 페이지 폴트(Page Fault)
PTE에 없으면 Page Fault -> 메모리 접근 에러
* 운영체제가 예외 핸들링을 통하여 처리
* Commit -> 첫 번째 접근 -> PTE 세팅 -> 우리에게는 예외가 발생하지 않는다.

DEBUG 빌드에서는 한 방에 접근 발생
* 일정 값으로 밀어버리기 때문

메모리 누수는 커밋 크기를 봐야한다.
* 커밋이 계속 증가하는지

### Reserve 왜함?
* Commit을 더 효율적으로 하기 위함
* 지연처리를 위한 역할

성능이 떨어졌을 때 페이지 폴트도 원인이 될 수 있다.