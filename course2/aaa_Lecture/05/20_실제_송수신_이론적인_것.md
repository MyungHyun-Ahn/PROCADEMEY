# 송수신 관련 이론적인 것
### 슬라이딩 윈도우
send 50 / 100 / 70

recv는 어떻게 쪼개고 어떻게 합쳐질까
* 이걸 판단하는 것이 윈도우

윈도우 : 버퍼 크기
* 상대방의 수신 버퍼 크기를 항상 알고 있다.
* TCP 헤더의 윈도우는 항시 들어간다.
  * TCP 윈도우 크기 필드 : 16 비트 - 65535
  * 그러나 현재는 이 사이즈에 TCP 옵션 필드에 있는 숫자만큼 오른쪽 시프팅 한 값을 실제 수신 윈도 사이즈로 받아들임 - window scaling
  * 최대 1GB까지 설정 가능하게 한다.

윈도우 사이즈를 알고 있음으로
* 여러개의 세그먼트를 한 번에 전송하는 것이 가능

송수신 버퍼는 연결 개수만큼 생성된다.

### 데이터가 쪼개져서 전송되는 경우
1. 상대방의 윈도우 사이즈가 작아서
   * 내가 보내고자 하는 사이즈가 MSS보다 작은데 쪼개져서 가는 경우
   * 상태방이 recv를 하지 않았기 때문에 윈도우 사이즈가 작아진 경우
   * 일반적으로 발생하지는 않는다.

ZeroWindow
* -> 아직도 없냐고 계속 확인 (zero window probe)
  * 그냥 ACK
* -> Zero window가 풀리면 TCP window update ACK를 보냄
* 만약 zero window 상태에서 probe를 지속적으로 보내는 상태가 지속되어도 TCP에서 직접 연결을 끊진 않는다.
  * L7 레이어에서는 끊을 수도 있다. (자체적 판단)

2. send 한 데이터의 크기가 MSS 보다 커서 쪼개지는 경우
* MTU(Maximum Transmission Unit) : IP 데이터그램의 최대치 - 이더넷이 담을 수 있는 페이로드의 최대크기
* MSS(Maximum Segment Size) : MTU에서 IP, TCP 헤더의 40바이트를 제외한 TCP 페이로드의 최대치
  * 1460

MTU 확인 명령어
* netsh interface ipv4 show subinterfaces

TCP는 절대로 MSS 이상의 TCP 페이로드를 전송하지 않음
* 1460 이상이면 무조건 쪼개짐

1. 네이글 알고리즘에 의해 쪼개지는 경우

### 네이글 알고리즘
* 버퍼링 했다 보냄 - 즉, 모아서 보낸다.
* 기본적으로 작동 중

네이글 알고리즘 작동 방식
* MSS에 도달하면 전송
* ACK가 도착하면 전송
  * 처음엔 그러면 언제보내는가?
  * TCP 3 way handshaking에 의한 ACK 때문에 전송 가능

우리는 보통 네이글을 켜고 간다.
* 보통 클라이언트는 끔 -> 들어오는 것에 대한 비용은 부과되지 않기 때문
* 서버는 켠다 -> 나가는 패킷 비용 부과됨


### 패킷이 뭉쳐져서 수신하는 경우
1. 네이글 알고리즘
2. 수신측에서 recv가 늦어져 수신버퍼에 쌓임
3. 수신 측의 윈도 사이즈가 0이어서 못 보내다 풀리고 한번에 보내는 경우

### 네트워크 코드 중 느린 부분
* 송수신이 제일 느리다.
* recv, send의 횟수를 최대한 줄여야 한다.

### 혼잡 윈도우
* 발신자 측에서 판단해서 윈도우 크기를 키움
* 나중에 다룬다.