# 소켓 API 2
### 논페이지드 풀
* 페이징을 하지 않는 풀
* 페이지 아웃이 안됨
  * 물리 메모리에 항상 상주하는 코드
  * 대개 드라이버 코드
* 한계치가 정해져 있다.
  * 오작동이 예측안됨 - 블루스크린
* 송수신 버퍼나 백로그 큐가 여기에 해당

### 백로그 큐 개수 손데야 하는가?
accept 스레드를 따로 만들면
* 1초에 9000개 정도의 접속을 받을 수 있다고 한다.
* 딱히 손댈 이유는 없다.

그러나 악의적인 상황에서 백로그 큐가 차는 현상이 나올 수 있다.

연결을 끊어도 백로그 큐에는 남아있다.
* recv, send 할 때 끊어진 것을 알 수 있다.

### 백그라운드 서비스
* 백그라운드로 실행됨
* 스타트 루틴으로 등록하면 전원이 켜질 때 수행됨
* main 문이 바뀌어야 한다.
* 더블클릭으로 실행이 불가능하다.
  * 레지스트리에 등록해야 함

### accept
* INVALID_SOCKET 인 경우 - 거의 없다.
* listen 소켓이 없을 때 발생

### recv
* retval == 0
  * 정상 종료

에러
* 비정상 종료

정상 종료와 비정상 종료 똑같은 처리 -> 구분을 안함
  * 단 에러는 에러 코드를 수집하자.

### connect
* 3 way handshaking이 성공하면 반환
* 서버 listen 소켓의 백로그 큐가 꽉 찼다면 SOCKET_ERROR
    * 이때 서버가 루프백 IP -> 바로 에러 -> RST 패킷 전송
    * 아닌 경우 -> 약간 대기

### RST
* TCP 연결 종료를 위한 비트
* 바로 연결을 끊기 위함
  * 4 way 과정을 안거치고


### 연결이 잘 안되면
* SYN 재전송
* 점점 SYN 재전송 타이밍을 늦추며 재전송
* 이때 netstat을 확인하면 SYN_SENT 상태로 보인다.
  * 5번 보내도 응답 없으면 실패

원인
* 연결대상 없음
* 방화벽 - 인바운드 설정 문제
* 상대방이 listen을 안함

연결 확인 과정
* netstat 확인 SYN_SENT 상태 - 재전송 시도 중
  * 바로 상태가 사라지면 RST라도 온 것 도달은 했음

SYN_SNET 상태에서 해야할 것
1. 서버 소켓이 listen 상태인지 L7
2. 방화벽 설정 확인 L4
3. ping 명령어를 통한 확인 L3
   * 이래도 안가면 통신 자체가 실패
4. tracert로 어디까지 가는지 확인

### TCP 연결
연결 과정
1. SYN 1 ->
   * SYN -> 번호를 맞추는 것
   * 시퀀스 넘버 : 바이트 단위로 올라감
   * 패킷의 맨 앞 위치의 데이터가 몇 번째 바이트에 해당하는지
2. <- SYN + ACK (1 + 1)
3. ACK 1 ->

페이로드가 없다면 + 1
* 번호를 붙여주기 위함
* 멤버 없는 클래스 크기가 1바이트인 것처럼

### 이더넷 PC에 여러개 연결 가능
* IP를 2개 할당
* 1개는 공인, 1개는 사설 이런 식으로 가능

0.0.0.0으로 바인드 하면 두 곳에서 모두 받는다.

127.0.0.1fh 바인드 하면 내부 통신만 한다.

### Send
* 리턴 되더라도 데이터 전송에 성공한지는 모른다.
* 데이터를 송신 버퍼에 보내기만 한 것
  * 블락킹 모드일 경우
  * 1000을 보내면 1000 리턴 혹은 대기

### recv
* len 우리가 받는 버퍼의 크기
* ret 받은 크기

무조건 TCP의 수신단에는 링버퍼를 넣자
* 송신단에는 데이터가 쪼개질 일이 거의 없음
  * 그냥 보내면 됨
* 수신단에는 쪼개져서 도착하는 경우 때문에 필수