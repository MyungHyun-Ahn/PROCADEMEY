# TCP 2
### closesocket 기능
* 언제 리턴?
* 송신 버퍼 남음
* 어떤 방식으로 종료

1. closesocket 바로 리턴 -> 보내기 시도 후 FIN을 보냄
* 수신버퍼 모두 꺼내진 후
* return 0 -> recv

2. closesocket 바로 리턴 -> 송신 버퍼 비우고 강제 종료
* FIN을 보내지 않고 RST를 보낸다.
* 송/수신 버퍼 모두 비우고 return 0

3. 데이터를 모두 보내고 정상 종료
* 모두 보내지 못하면 TCP 연결 강제 종료 후 리턴
* 보내고 확인까지 진행

LINGER 옵션을 걸지 않으면 1번으로 수행
* 우리가 원하는 것은 2번

LINGER 옵션의
* l_onoff = 1; : 켠다.
* l_linger = 0; : 2번
* l_linger = 양수; : 3번

### TCP 연결 종료 4 way handshake

상태 흐름
* FIN_WAIT1 -> FIN -> CLOSE_WAIT
* FIN_WAIT2 <- ACK <- 
* TIME_WAIT <- FIN <- LAST_ACK
* -> ACK -> CLOSED

FIN은 L7에서 우리가 제어
* closesocket() 혹은 shutdown()

ACK가 유실되면 FIN_WAIT1 상태
* 최소한 몇 십초 대기

FIN_WAIT2 -> 상대측에서 안 끊어 주는 것

TIME_WAIT
* 일부러 대기 하는 것
* 레지스트리를 조정하는 조절 가능

### TIME_WAIT의 목적
해당 포트로 다시 바인드 되는 것을 막기 위해
* 만약 3-way handshake 도중 잘못된 패킷이 오면 연결 중단
  * 그냥 RST 패킷을 보내버림

UDP는 모든 데이터를 그냥 막 받음

TCP는 주소, 시퀀스, ACK 모두 맞아야 받음

클라이언트 포트가 부족한 경우
* 많은 연결 시

서버가 먼저 끊는 경우는 뭐가 있을까?
* 비정상 유저 -> 핵쟁이

TIME_WAIT 이 많이 남으면??
* TCP 연결 정보가 남는다.
* 모두 논페이지드 풀로 간다.

우리는 TIME_WAIT이 남지 않도록 한다.

TIME_WAIT 상태는 왜 끊는 쪽이 가지게 될까?
* 한쪽에만 둬도 연결을 막을 수 있다.
* 송수신 IP 쌍을 가지기 때문에
* TIME_WAIT은 먼저 끊기 시도한 쪽의 패널티 같은 것

### RST
RST로 연결을 끊으면
* TIME_WAIT 상태를 남지기 않는다.
* FIN_WAIT 단계가 되면 우리가 RST 패킷을 보낼 방법이 없다.
  * 연결 제어가 끊기 단계로 이미 넘어감

shutdown() -> LINGER를 못보냄
* 절대 쓰면 안된다.
* FIN을 보내는 것

TIME_WAIT이 남았을 때 서버의 리소스 부족이 우려됨

### 송수신 버퍼 크기

SO_SNDBUF, SO_RCVBUF 옵션으로 송수신 버퍼 초기 크기를 정할 수 있다.
* 윈도 커널이 내부적으로 버퍼를 확장하기도 한다.
* 서버가 recv를 하지 않으면 수신버퍼가 확장 -> 논페이징풀이 늘어남

실제로 윈도우 크기는 MSS 경계 단위로 크게 잡음
* 대충 2배크기
* 8000 -> 16760 = 8000 + 1460 * 6
* 우리가 직접 설정한 것보다 여유를 잡는다.

최대 크기
* revbuf = 1024 * 1024 * 999
* 1GB에 근접

논페이징풀은 동적으로 늘려간다.
* 부족할 때 확장
* 바로 확장하지는 않는다.

### 송수신 버퍼 조절
송신 버퍼의 확장단위 MSS의 경계 단위

TSO(TCP Segmentation offload)
* 이더넷이 제공하는 기능
* TCP 패킷 분할을 CPU가 아닌 NIC가 수행
* 따라서 MSS보다 큰 바이트를 보낼 수 있음

송신측에서 패킷 캡처를 하면 패킷이 짤리지 않는다.

수신측에서는 MSS 크기로 짤려서 도착한다.
* 이더넷이 짤랐음

### Selective ACK
패킷이 짤려서 갈 때 만약 1, 2, 3, 4, 5가 있고
* 4가 유실되면? 보통 4, 5를 다시보낸다고 알고 있음
* 그러나 이건 과거의 이야기

Selective ACK
* 연결 수립 때부터 옵션 필드에 기입되어 있어야 함
* 양측 장비 모두 SACK를 지원해야 함
* 옵션 헤더를 활용해서 받을 ACK만 선택해서 받는다.

### recv 리턴 타이밍
recv 데이터 있으면 리턴
* 데이터가 없으면 block

### TCP 헤더 PSH option
* flush 동작에 의해 송신된 데이터임을 나타냄.
  * send 함수 같은 것
* 제일 마지막 패킷에 PSH 옵션이 켜진다.
* MSS 미만의 크기 데이터는 항상 켜진다.
* L7 단위의 송신 요청을 표시
* L7 측에서 받아봤다 할일이 없기 때문
  * 쓸모없는 recv 최소화

blocking 된 경우
* 우리 버퍼로 그냥 데이터가 들어옴

수신 버퍼
* recv를 걸지 않았을 때의 대비용