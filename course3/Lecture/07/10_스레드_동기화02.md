# 스레드 동기화 02
## WaitOnAddress
* Windows 8에서 처음으로 등장
* 최신 기술
* Synchronization.lib를 링크해야 사용 가능

msdn 설명
* 주소의 값이 변경될 때까지 기다립니다.
* ? 무슨 이상한 소리 -> 잘못됨
* 값이 변경되는 것을 탐지하는 것은 기술적으로 말이 안됨

그럼 값을 언제 쓰는가?
* 처음에만 Address와 CompareAddress의 값을 비교
* 값이 같으면 다른 스레드가 값을 변경할 때까지 대기 -> 사실은 아님
  * 값이 변경된건 모른다.
* 단지, 값이 다르면 리턴, 같으면 블락 여부만 결정하는 함수

### WakeByAddressSingle
* 주소를 기다리는 스레드 1개를 깨움

주소를 키로 기다리고 있는 목록이 존재함
* 유저 영역에 존재
* 이런 모든 관리를 유저 모드에서 진행한다.
  * 대기 여부 판단을 유저에서 한다는 것
* 당연히 스레드를 깨울때는 커널 전환이 필요

위 두 함수를 활용해서 동기화 객체처럼 사용이 가능

## 동기화 객체 구현
```C++
Lock()
{
    if (InterlockedExchange(&Lock, 1) == 1)
        WaitOnAddress(&Lock, &Compare, 4, INFINITE);
}
```

```C++
UnLock()
{
    // 0 으로 바꾸는 행위를 언제 진행할까?
    // Lock = 0;
    WakeByAddressSingle(&Lock);
    // Lock = 0;
}
```
* Lock을 언제 대입해도 문제가 된다.
* 1인 상태에서 블락 -> 0으로 바꿈 -> 바꾼다고 해도 계속 블락 상태
* 혹은 둘이 진입하는 경우도 발생 가능

대기하고 있는 스레드 또한 다시 경쟁에 참여하게 해서 해결
* if를 while로 바꿈

```C++
while(1) // N개의 스레드가 진행
{
    Lock();

    // 할일 진행

    UnLock();
}
```
* UnLock() 이후 다시 자기 자신의 스레드가 락을 획득할 확률이 매우 높다.
  * 스레드가 깨어나고 -> Lock을 취득하는 과정이 느림

만약 Lock을 커널 오브젝트로 구현했다면?
* 이건 무조건 스레드 전환이 일어난다.
* 깨울 스레드를 정하고 깨운다. -> 무조건 스레드 전환 발생

## WaitForSingleObject, WaitForMultipleObjects
커널 오브젝트는 두 가지 상태를 가짐
* 시그널, 논-시그널

대기하는데 사용할 수 있는 커널 객체
* 이벤트 객체
* 뮤텍스
  * 커널 동기화의 장점은 없다.
  * 안쓴다.
* 스레드

스레드 종료를 확인하는 가장 확실한 방법?
* 시그널을 확인하는 것

### WaitForSingleObject
DWORD WaitForSingleObject(핸들, 시간);
* 커널 객체 핸들과, ms 단위의 타임아웃 시간을 넣어 사용

리턴값
* WAIT_FAILD : 핸들이 잘못된 경우에만 발생
  * 이미 넣은 핸들이 잘못되는 경우는 없다.
  * CloseHandle을 하더라도 WaitForSingleObject에서 사용 카운트가 올랐으므로 핸들이 삭제되지 않음
* WAIT_OBJECT_0
  * 객체가 시그널 상태가 되었음
* WAIT_TIMEOUT : 타임아웃
* WAIT_ABANDONED_0 : 뮤텍스 객체일 때 뮤텍스를 소유한 스레드가 해제하지 않고 종료

### WaitForMultipleObjects
DWORD WaitForMultipleObjects(개수, 핸들 배열, WaitAll, 시간);
* 핸들 객체를 최대 64개까지 등록하여 전달 가능

만약 WaitAll에 TRUE를 전달하면
* 전달한 모든 객체가 시그널 상태가 될때까지 대기

FALSE를 전달하면 1개만 시그널 되어도 반환
* 반환값이 시그널 상태가 된 객체의 인덱스

여러개가 동시에 시그널 상태가 될 수 있나?
* 불가능하다.
* 동시에 시그널 상태가 될 수 없다.
* 하나가 시그널되자마자 반환되는 것

만약 이미 시그널 상태인 배열을 넣는다면 앞에껄 먼저 탐지함

WaitFor_Object API를 사용하면
* 커널 오브젝트에 스레드를 등록한다.
* 이 커널 오브젝트가 시그널이 되면 직접 스레드를 깨우는 것

만얀 WaitAll이 TRUE인 경우에는
* 커널 오브젝트가 스레드에 가서 상태 변수를 조작
* 모두 시그널이 되면 그때 스레드가 깨어남

스레드 종료 혹은, 이벤트 아니면 활용도가 떨어짐