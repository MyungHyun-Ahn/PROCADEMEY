# 스레드 API 1
## 스레드 종료
ExitThread()
* 스레드 내부에서 자신을 강종

TerminateThread()
* 정상적인 종료 루틴이 발생하지 않는다.
* 위험한 방법
* 완전히 복구가 불가능한 상태에만 사용
* 왜 하는가? -> 더 이상 이 스레드가 무슨 짓을 할지 모르기 때문
  * 알수없는 메모리 접근 수정 등

return 으로 종료
* 정상적인 종료
* return을 하면 ExitThread가 호출됨
* return을 매우 권장 - 이것만 쓸 것


스레드 종료 코드 확인
* GetExitCodeThread(HANDLE hThread, LPDWORD lpdwExitCode);
* 만약 STILL_ACTIVE를 반환하면 아직 종료되지 않은 것

스레드 종료 여부 확인 방법
* GetExitCodeThread의 STILL_ACTIVE 반환
* 스레드 커널 오브젝트의 시그널 상태 확인 - 시그널 종료
  * WaitForSingleObject로 확인

## 스레드 대기 상태로 만들기
DWORD SuspendThread(HANDLE hThread)
* 카운터로 시작, 대기를 결정
* 호출 횟수당 카운터 +1
* 성공 시 이전 대기 카운터 값
* 실패 시 0xFFFFFFFF

DWORD ResumeThread(HANDLE hThread)
* 카운터 -1

이거 쓸까?
* 스레드 제어 작업임
  * 다른 스레드를 쉬게하는 것은 바람직하지 않다.
  * 본인이 쉴지 말지를 결정해야 함

### 스레드도 생성하는 시간이 있다.
여러개 생성해서 땅~ 하는 테스트 프로그램
* 제일 첫번째로 생성된 스레드가 호로록 끝내버림
* 결국 싱글처럼 동작하는 결과가 나올 수 있음

이럴 때는 Suspend 상태로 생성하고 Resume

## 스레드 대기
void Sleep(DWORD dwMilliseconds);
* INFINITE - 무한 대기
* 0 -> 퀀텀 포기 -> 컨텍스트 스위칭을 유도
* 1 -> 1ms 휴식

Sleep(0)을 하는 경우
* 코어가 적을 때
* 여러개의 스레드를 빠르게 전환하고 싶을 때
* 어떠한 상황을 재현하는 용도
  * 동작 순서 제어

BOOL SwitchToThread();
* 그냥 레디큐에 있는 다른 스레드 선택
* Sleep(0)하고 결국 지금은 같다.

Sleep(0)과 비교 - 과거엔 그랬음
* 동일한 우선 순위 중 선택 -> XP 시절
* 낮은 우선 순위면 그냥 진행
  * 지금은 아니다/

### 스레드 모니터링 단위
* 초단위 - 원하는 순간을 잡기 힘들다.

## 스레드 생성
CreateThread 함수
* 사용하지 말자
* 대부분의 프로그램이 C 런타임 라이브러리에 의존하기 때문
* C언어 관점에서는 갑자기 운영체제에서 생성된 Thread로 인식

스레드에 의존하는 코드
* rand() -> 시드값 저장 -> GetPtd -> 스레드마다 보관되는 공간에 있음
* strtok -> 파라미터 정보를 내부에서 기억

_beginthreadex() 를 사용하자
* _endthreadex() 와 짝을 지어 사용
  * 그러나 return을 더욱 권장
  * 지역 객체의 소멸자를 정리해주지 않기 때문에
    * 컴파일러가 만든 것 - 지역 객체 -> 소멸자 안 지워줌
* C 런타임 라이브러리의 초기화도 함께 진행됨

사실 CreateThread를 하여도 수행에는 문제가 되지 않음
* 의존성 있는 부분을 사용할 때 초기화가 일어남
* 대신 종료 시에 정리되지 않는다.

### 메인 스레드 종료 전 생성한 모든 스레드가 종료되었는지 확인 필수
* atexit 함수를 통해 호출되는 전역 객체의 소멸자를 호출할 때 종료되지 않은 스레드 때문에 오작동을 일으킬 수 있다.
* 이미 삭제된 Manager 클래스의 접근 등

### _beginthreadex 어떻게 동작?
```C++
_beginthreadex(..., threadFunc, ,,,)
{
    // threadFunc을 래핑한걸 전달
    CreateThread(..., ThreadStart, ...);
}

ThreadStart()
{
    // 시작 코드

    threadFunc()
    {
        return;
    }

    // 정리 코드
}
```

## 프로세스 스레드 우선순위
최종 우선순위 = 프로세스 + 스레드 우선순위

우선순위를 올려서 이득을 보는 상황
* CPU 사용률 100%
* 레디큐에 뭐가 있을 때

언제 우선순위를 조정해볼까?
* DB 저장
* 로직을 재쳐서라도 빨리하는게 좋다.
* 저장할게 밀리면 롤백도 느려지고, 데이터가 쌓인다.

레디큐에 있는 순간
* 빠르게 선점될 수 있다.
* 이용률 80% 언저리일 때 항상 레디큐가 비어있는 상황만 있는 것은 아니다.

## 우선순위 부스팅
우선순위를 운영체제가 올려주는 상황
* IO 대기 스레드에게 IO가 완료되면 운영체제가 우선순위를 올림
* 창 순서에 따라 우선순위가 다름 - 활성 창

### 기아 현상 
선택 받지 못한 스레드
* 운영체제가 개입해서 해결

어떻게 해결?
* 1초에 1번 벨런스 셋 매니저 스레드가 레디큐를 스캔해서 4초 이상 머무는 스레드를 본다.
* 찾은 스레드를 15(최대치)로 우선순위를 올린다. -> 수행 후 다시 돌려놓음
* 한번에 16개 씩만 검사, 한번에 10개 스레드만 우선순위 상승

## Interlocked 함수
원자적 연산을 보장하는 함수
* CPU 차원에서 제공하는 연산

전체 조건
* 인자로 들어가는 크기의 정렬이 지켜져야 한다.
* 경계가 안지켜지면 보장하지 않는다.

인텔 프로세서에서
* 캐시 라인 안에만 들어오면 보장 -> 지금은

InterlockedCompareAndExchange
* 16 바이트 경계에 안세우면 오류

인터락 함수의 리턴값을 많이 활용
* 이 값에 의존한다.
* 무슨 값으로 증가시켰는지 혹은 어떤 값에서 변화했는지 확인할 수 있는 유일한 방법

어떻게 작동하는가?
* 메모리를 락 걸어버린다.
* 캐시 라인 자체를 잠구어버린다.
* 속도는 당연히 떨어진다.
* 변수가 같은 캐시라인에 붙어 있다면 같이 잠겨버린다.
  * 인터락은 인터락끼리만 호환

인터락 함수 다양함
* 찾아보고 쓸 것 -> msdn