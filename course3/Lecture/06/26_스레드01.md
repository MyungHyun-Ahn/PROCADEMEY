# 스레드01

## 선점형 / 비선점형
선점형(preemptive)
* 운영체제가 주도권 소유

비선점형
* 스레드 코드가 제어를 결정

운영체제의 관점에서는 반드시 선점형

## 유저 모드 스레드
유저가 관리하는 스레드
* 운영체제 입장에서 볼 때 비선점형
  * 존재 자체도 모른다.
* 파이버
  * 운영체제 차원에서 지원
* 코루틴
  * 언어 차원에서 지원

코루틴
* 하나의 스레드 안에 독립적인 콜스택을 가진다.
* 한 스레드 안에서 번갈아 가면서 한 스레드 위에서 돈다.

```C++
A()
{
    B()
    {
        C()
        {
            yield(); // X()의 실행 흐름으로
        }
    }
}

X()
{
    yield(); // C()의 실행 흐름으로
}
```
* yield가 호출될 때마다 왔다 갔다.
* 유니티의 경우에는 추가적인 조건이 있어 yield를 사용하지 않아도 알아서 전환이 발생

코루틴 자체는 비동기는 아니다.
* 논블로킹
* 비동기 처리 함수와 자주 쓸 뿐

## 프로세스 = 구조체 덩어리
* 스레드가 실행 단위

## 좋은 멀티스레드 프로그램
고려해야할 요소
* 수행 시간
* 사용자 응답성
* 프로그램 구조

위 셋 중 적어도 하나 이상은 싱글 스레드 프로그램보다 우수
* ex) 기능에 따라 분리

## 세 개의 스레드 동시 실행
A, B, C 스레드가 잘돌 수 있는 조건
* 경합이 발생하면 안된다.
* 코어(물리 프로세서)가 3개 이상 있어야 한다.

게임의 경우에는 이게 잘 안된다.

## 멀티 스레드 프로그래밍에서 걱정하는 것
어떤 스레드가 오류가 발생하더라도 나머지 스레드라도 잘 작동하게 하는 것
* 이거 괜찮은가?
* 급한 불을 끄고 다시 재개 -> 다시 같은 버그가 발생할 수 있음
* 안정성을 위해 멀티 스레드를 사용하는 것은 잘못된 것

안정성을 위해 멀티 프로세스로 처리한다면 OK

DB에서 많이 사용하는 방식
* Master Active와 Standby 두 프로세스를 둠
* Master가 다운되면 Standby가 Master가 됨
* Master는 Standby에 데이터를 계속 백업

그런데 여기서 걱정하는 것은?
* 물리적인 문제를 걱정하는 것
* 하드웨어 문제 혹은 자연재해

게임 서버에서는 소프트웨어적인 문제를 더 걱정
* 멀티 프로세스로 나누는 것은 별로 의미가 없음
* 성능 저하 등의 부작용이 더 큼

## 예외는 스레드에서 발생하는 것
예외 -> 스레드 -> 해당 논리 프로세서에서 발생
* 내 프로그램의 다른 스레드는 작동
* 실제로 프로그램은 예외처리기가 끄는 것
  * 예외를 처리하면 안 꺼짐

예외를 처리하고 스레드를 다시 켜는 방식도 채택 가능
* 아래의 형태만 적용 가능
  * 스레드 풀 형태
  * 기능 별로 스레드를 잘 분리

그런데 예외를 처리하고 스레드를 다시 살림?
* 해당 문제가 다시 발생할 수 있음
* 손상된 메모리를 계속 조작할 수 있음

## 스케줄링
스케줄링 단위
* 과거 리눅스 - 프로세스 스케줄링
  * 스레드 개념이 없었음
* 지금은 스레드 단위 스케줄링으로 동작
  * 프로세스 내 모든 스레드는 같은 메모리를 본다.

윈도우는 우선순위 라운드 로빈(Round-Robin) 방식
* 라운드 로빈 - 뺑뺑이를 돌면서 스케줄링
* 우선순위 별로 라운드 로빈 큐를 여러개 둠

## 퀀텀 혹은 타임 슬라이스
* 스레드는 퀀텀이라는 시간 단위만큼 실행 가능
* 퀀텀을 모두 사용하면 다른 스레드로 실행 권한이 넘어감

퀀텀을 모두 사용할 수 있을까?
* 그런 경우는 매우 드물다.
* 왜? - I/O 작업이 발생하면 퀀텀을 포기
  * 그런데 I/O을 안하는 프로그램은 매우 드물다.
  * 퀀텀을 완전히 사용하려면 연산 작업으로만 이루어진 프로그램이어야 함

퀀텀의 길이가 달라질 수 있는 이유
* 시스템 구성 설정
* 포그라운드, 백그라운드 프로세스 상태
* 퀀텀을 변경하기 위한 잡 객체의 사용 여부

인터럽트는 퀀텀을 포기하지 않는다.
* CPU에 잠깐 인터럽트 처리 루틴(코드)을 끼워 넣는 것
* 인터럽트가 발생해도 여전히 스레드는 running 상태

커널 모드 전환이 퀀텀을 포기하는 것은 아니다.
* 단지 커널 코드를 돌리는 것
* 스레드는 여전히 running

## 컨텍스트 스위칭
* 레지스터 정보를 비우고 다시 세팅하는 것
* 운영체제는 컨텍스트 스위치 이후 다른 스레드를 선점

운영체제는 스레드 단위로 스케줄링을 하기 때문에 프로세스를 구분하지 않음
* 스케줄링 이후 CR3 레지스터(페이지 테이블을 가리키는 레지스터)가 그대로라면 캐시, 페이지 테이블 등을 그대로 활용할 수 있어서 효율이 좋다.
  * 같은 프로세스의 스레드로 스케줄링 되었을 때

## 컨텍스트 스위칭 발생 기준
* 타이머 인터럽트(0번)가 n회 발생해야 -> 컨텍스트 스위칭 발생
* 스레드마다 퀀텀 타겟이라는 것을 가지고 타이머 인터럽트가 발생할 때마다 차감됨
  * 퀀텀 타겟이 0이 되면 컨텍스트 스위칭 발생
  * 윈도우즈 서버는 2배다.
    * 서버 운영체제에서는 특정 프로세스만 동작
    * 더 많이 돌라고

## 레디 큐
CPU 코어마다 레디 큐라는 것이 있음
* 실행될 스레드가 대기하는 큐

레디 큐에 스레드가 있다는 것의 의미
* CPU 사용률이 100%이어야 한다.
* 돌지 못하고 있는 스레드가 있다.

CPU 사용률은 100%를 만들면 안된다.

## 윈도우 운영체제 종류
* Windows Desktop - GUI 있음
  * 기본적으로 실행되어야 하는 프로세스 많음
  * 아무것도 안켜도 CPU 사용률이 10% 정도 나옴
* Windows Server Core - GUI 포함 안함
* Windows Nano Server
  * 코어 모드와 유사하지만 매우 가벼움
  * 그러나 윈도우에서 제공하는 서버 프로세스만 활용 가능
  * 완전히 MS 특화

## TCB(Thread Context Block)
* 스레드의 레지스터 정보 등 스레드 정보가 담겨있음
* 커널(시스템) 메모리 영역에 위치

## 윈도우에서 스레드 대기(SUSPENDED) 상태
* 이유가 항상 있다.