# 스레드 02

## CPU에 스레드가 붙었다는 의미
* 해당 스레드가 Running 상태
* 해당 CPU의 레지스터가 스레드의 정보로 세팅되었다는 의미
  * 이때부터 스레드 스택, 코드 실행 지점, 가상 메모리 등이 보이게 됨

## 세그먼트 레지스터
* 과거 메모리 영역을 분리하는데 사용
  * 가상 메모리가 등장하고 사용하지 않음
* 지금은 메모리 속성들을 관리하는데 사용
  * 실행 대상? 커널 유저 메모리? 등을 구분하는데 사용

Code Segment Register
* 명령어 주소 계산

Data Segment Register
* 데이터 영역의 데이터 세그먼트 위치

Stack Segment Register 등이 존재했음

지금은 속성 정보 저장 용도

## 인터럽트
* 내 코드와는 상관없이 외부에서 치고들어오는 코드

인터럽트 종류
* 하드웨어 인터럽트(비동기)
  * 0번 인터럽트 - 타이머 인터럽트
    * 운영체제의 스케줄러가 여기에 의존
    * 0번 인터럽트 핸들러 - 타이머 체크, 스케줄러 기능을 수행
* 소프트웨어 인터럽트(동기)
  * 예외는 프로세스 코드에서 발생 - 동기 인터럽트

사실 우리 입장에서는 둘 다 비동기
* 프로세스 코드 수행 도중 언제든지 끼어들 수 있기 때문.

## PIC(Programmable interrupt controller)
인터럽트 컨트롤러
* 인터럽트 처리를 위한 하드웨어
* IDT(Interupt descriptor table) : 인터럽트 번호마다 예외 핸들러(ISR, Interupt service routine)를 등록
  * 함수 포인터들이 들어있는 것과 비슷
* PIC를 통해 외부에서 들어오는 인터럽트 신호를 CPU에 전달

인터럽트 신호를 받은 CPU는 최소 단위 오퍼레이션을 끝낸 직후 인터럽트 핸들러로 제어권이 넘어간다.
* 컨텍스트 스위칭에 준하는 행위
* 커널 스택으로 전환이 되어야 함 - 캐시 미스 등 발생

스레드마다 커널 스택 보유
* 예외는 스레드 관점
* CPU 마다 커널 스택을 가지게 된다면?
  * 현재 스레드 상태를 유지할 수 없음
  * 다른 스레드가 덮어쓸 수 있음

커널 스택 크기 = 3페이지(12K)
* 스레드마다 나눠지는 것 - 공유 X

## 인터럽트 레벨
### 하드웨어(ISR, Interupt Service Routine)
* 하드웨어 신호로 인해 빠르게 처리되어야 함
* 수행 시작된 ISR은 해당 CPU 내에서 완료되어야 함
* 25us 미만으로 실행되어야 한다.
* 하드웨어 인터럽트 처리가 늦어지면?
  * 하드웨어 버퍼 크기가 크지 않기 때문에 다른 것들의 처리가 밀릴 수 있다.
* 시간 내에 처리 못한 작업들은 우선순위가 낮은 DPC로 우회하여 하드웨어 인터럽트를 모두 처리하고 나서 처리

여기부터 소프트웨어 인터럽트

### 지연된 프로시저 호출(DPC, Defered Procedure Call)
* 낮은 우선 순위의 인터럽트를 지연시켜 처리
* 100마이크로 초 미만으로 수행되어야 함
* DPC는 CPU 마다 있다.
  * 큐같은 것

ISR / DPC 까지 모두 처리 완료 후 디스패처 수행

### 디스패처
* 스케줄러는 컨텍스트 스위칭 여부까지만 판단하고 디스패처 인터럽트를 발생시킴
* 이 디스패처 인터럽트를 받아 실질적인 컨텍스트 스위칭을 수행한다.
  * 스레드 백업하고 레디큐에 삽입
  * 내 CPU 레디큐가 비었다면 다른 CPU의 레디큐에서 스레드를 가져온다.
* 컨텍스트 스위칭 후 디스패처의 핸들러부터 수행을 재개하게 됨
  * 즉, 모든 스레드의 진입부는 디스패처
* A -> B 컨텍스트 스위칭 과정
  * A 스레드 유저 모드 -> A 스레드 커널 모드 -> B 스레드 커널 모드 -> B 스레드 유저 모드

스레드 스케줄링, 컨텍스트 스위칭
* 타이머 인터럽트의 발생부터 시작

### APC

### 유저

요즘에는 PIC가 CPU 내부로 들어간 LAPIC와 외부에서 각 CPU에 인터럽트를 배분해주는 APIC로 발전

## Page fault 인터럽트
* 메모리 접근 오류(예외) -> 운영체제의 핸들러가 먼저 받는다.
* 소프트웨어 인터럽트

그런데 하드웨어 인터럽트를 처리하는 도중 Page fault가 발생하면
* 블루 스크린
* 따라서 하드웨어 인터럽트가 발생할 수 있는 메모리는 논페이지드 풀을 사용한다.
  * 예외가 발생하지 않도록 하기위함

## 최소 단위 오퍼레이션
만약 아래 코드를 2개의 스레드에서 수행
* a++; 을 1000번 수행

기대값 -> 2000
* 그러나 2000이 안될 가능성이 매우 크다.

```C++
mov eax, [a]
add eax, 1
mov [a], eax
```
* 연산이 3번에 걸쳐 이루어진다.
* 연산 순서가 꼬이게 되면 문제가 생긴다.

```C++
// 스레드 1
b = a;

// 스레드 2
a = 0;
a = 0xffff;
```
* 스레드 1과 스레드 2를 수행
* 0일지 0xffff일지는 보장
* 단, 캐시라인에 걸치지 않았을 때

최소 단위 오퍼레이션
* 어셈블리 1줄 짜리 명령어

## 교착 상태 (Dead Lock)
데드 락
* 영원히 풀리지 않는 락

만약 락 A와 락 B가 있으면
* ABBA 구조가 되면 데드락 상태에 빠진다.

데드락 조건
1. 다수의 자원에 대한 소유와 대기
2. 상호 배제
3. 무선점
4. 순환 대기

## GS 레지스터
스레드 관련 함수를 호출할 때 정보를 가져오는 레지스터
* GS 레지스터에 환경 블록 등이 들어간다.

## GetCurrentThread 함수
* -1 가상 핸들을 반환한다.
* CloseHandle 아무 영향 X

## GetCurrentThreadId 함수
* 매우 빠르다.

## 스레드 설계 관점
헤테로지니어스
* Scale Up에 유리
* 스레드마다 역할이 정해진 구조

호모지니어스
* Scale Out에 유리
* 스레드가 모두 같은 일을 한다.
  * Task, Job 구조
* 스레드 여러 개면 좋다.
* 코드 내부에서는 스레드 구분 불가, 같은 코드를 수행