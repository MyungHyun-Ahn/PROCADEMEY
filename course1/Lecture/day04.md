# day 04
## 포인터

int a = 0x11223344;
* 메모리 상에는 어떻게 저장될까?

11 22 33 44\
44 33 22 11
* CPU에 따라 다르다.
* 우리는 작은 주소의 값이 먼저 저장되는 구조를 따른다.

엔디안
1. 리틀 엔디안 : 작은 주소의 값이 먼저
2. 빅 엔디안 : 큰 주소의 값이 먼저

현재 대부분의 CPU가 리틀 엔디안을 사용한다.
* 우리 또한 (데스크톱, 모바일 등등)
* 굳이 꼽자면 모토로라 계열의 CPU가 빅 엔디안이다.

만약 데이터를 수신하는 쪽과 송신하는 쪽의 엔디안 규칙이 다르다면?
* 네트워크의 장비는 대부분이 빅 엔디안을 사용한다.

네트워크 환경 -> 렌선에서 전기 신호 -> 장비들이 해석

네트워크 장비에서는 빅 엔디안을 표준으로 따르고 있다.
* 실제 우리가 사용하는 데이터(게임에서 사용할)는 상관없지만
* 실제 수신지와 송신지는 모두 빅 엔디안으로 변환해야 한다.
* IP와 Port 정보

int a = 0x11223344;\
char *pch = (char *)&a;\
int x = *pch;
* 위와 같이 변환하면 어떻게 나올까?
* 시작 주소로부터 1바이트
* 즉, 0x44

short *psh = (short *)&a;\
int x = *psh;
* 0x3344

int a = 65535;\
unsigned char x = a;
* 255

## 다차원 배열
Color의 정보를 담는 크기
* 8bit
* 16bit : 대락 65000가지의 색을 표현 가능
* 24bit : 24bit부터 true color 라고 하기도 함
* 32bit : 현재 가장 많이 쓰는 것 - 4byte

그럼 FHD(Full HD) 1920x1080 = 200만 화소에서는 그림 한장의 크기가 얼마나 될까?
* 8294400바이트

이걸 조금이나마 줄이기 위해 이차원 배열에 타일 이미지를 배치시킨다.
* 그림을 배열에 표현하면 255개를 1바이트에 저장할 수 있다.
* unsigned char TileMap[200][200];

그냥 화면에 띄워놓고 충돌체크를 한다면
* 만약 500명이 있다면 매번 무수히 많은 오브젝트들을 체크해야 한다.

어떻게 리소스를 줄일 수 있을까에서 시작된 방식
* 게임 화면을 격자(조각낸다)로 나눈다. - Grid
* Grid 1칸에 그 칸에 있는 모든 오브젝트 정보를 담아둔다.
* 1칸이 구조체가 된다.

옛날 게임은 무조건 그리드의 중앙에만 서야한다.
* 요즘 게임에서는 그리드 내부에 list가 들어가서 여러명이 동시에 설 수 있다.
* 서버 측에서 로직이 복잡해진다.

3D 게임인 경우에도 2차원 배열을 사용한다.
* 그저 바닥에 있을 뿐
* 만약 날라다니는 게임이라면 -> flag를 주어서 날았는지 판단하자
* 월드 좌표와 그리드 좌표 둘 다 가지고 있어야함
* 서버에서 3D 계산은 최대한 피하자

검은사막에서는 그리드를 3차원으로 사용한다.

픽셀인데 3차원 -> 복셀
* 메모리 용량 문제가 발생할 수도 있다.
* 2차원 그리드에서 해결할 수 있는 컨텐츠가 편하다.
* 서버 개발자는 단순히 데이터만 들고 있으면 된다.

만약 연산이 느리다면
* 빠르게 하기 위해 미리 해둔다. -> 베이킹 한다고도 표현
* 미리 연산을 진행하고 테이블을 만든다.

옛날에는 삼각함수 연산이 엄청 느렸다.
* sin과 cos의 각도별로 모두 미리 계산해서 테이블을 만든다.
* float sinTable[360];


만약 게임 AI를 사용한다면? : 머신러닝 AI 말고 실제 게임에서 사용하는
* if 분기문을 사용 -> if 분기문이 너무 많이 들어간다.
* fsm 유한 상태머신을 사용 : 상태를 클래스로 묶은 것
* 언리얼 엔진 : Behavior Tree를 사용 : 트리로 묶은 것

완전 옛날에는 다차원 배열
* 좋다 ~ 싫다 5단계
* AItable[5][5][5][5];
* 내 레벨, 적 레벨, 거리, 내 HP ...
* 실제 사용할 때는 각 값에 변수로 넣어버림
* 이런 상황에서도 다차원 배열이 용이하다.

피보나치 수열 구현
1. 재귀
   * 장점 : 구현이 간편함
   * 단점 : 스택이 계속 쌓이기 때문에 자원을 많이 사용함
2. 반복문
   * 장점 : 비교적 빠르다. O(n^2)
3. 배열(DP)
   * 장점 : 이미 있는 값이 있다면 연산을 하지 않고 바로 답을 준다.


int main(int argc, char *argv[], char *env[]);
1. 인자 개수
2. 인자
3. 시스템 환경변수

* 요즘에는 잘 안쓴다.
* 스크립트 컴파일러 같은 거 만들 때 편하다.

C 표준 함수
1. strlen : 문자열 길이 계산
2. strcpy : 문자열 복사
3. strcmp : 문자열 비교 - return value 0이 아니면 다른 것
4. strcat : 문자열 붙이기
5. strchr : 문자열 내에서 특정 문자 검색
6. strstr : 문자열 내에서 특정 문자열 검색
7. strlwr : 문자열을 소문자로 변환 -> 대소문자 변환

* 결국 우리는 전부할 줄 알아야 한다.
* C++ string과 C-style String
* C++ string이 편하다는 것은 결국 메모리를 더 쓴다는 것

C-Style에서 copy, add 등의 함수는 메모리를 침범할 수 있다.
* _s가 붙은 버전의 문자열 처리 함수를 사용하자.


## 문자열
널('\0')로 끝나는 문자열 null terminated string
* 끝은 모른다. 매번 '\0'을 찾아야 한다.
* 문자열의 길이를 표기하면 문제는 해결된다. std::string

char *p = "abcd";
* a b c d


char Dest[5];\
strcpy(Dest, "abcdef");
* 메모리 침범 문제가 발생한다.

_s가 붙은 버전
* 길이 또한 받는다.
* 안전하지는 않다.

strcpy_s(Dest, 5, "abcdef");
* 초과된 영역을 잘라주지는 않는다.
* 크래시, 침범보다는 낫다.
* 안전 장치는 우리가 넣는다.

char szDest[100] = { 0, };\
memset(szDest, 0, 100);
* 항상 초기화해야할까?
* 낭비 : 너무 비효율적이다.

szDest[0] = '\0';
* 시작 문자가 '\0'이라면 문자열이 빈 상태

strcpy를 하기 전에 문자를 꼭 초기화할 필요는 없다.
* 명확하게 필요한 것만 하는 것이 좋은 프로그램이다.

무조건 처음이 대입?
* 꼭 초기화할 필요는 없다.

strcat는 널문자 찾는 로직이 들어갔다.

아스키 코드 -> 출력을 할 때 문자로 변환
* 실제로는 char 데이터 타입에 숫자가 들어간다.

'A'(65) 'a'(97)
* 대소문자의 데이터 간격이 32이다.
* 32를 더하거나 빼면 대소문자 변환이 가능하다.
* 대문자가 작고 소문자가 크다.
* 소문자 - 대문자


'A' 0x41 0b01000001\
'Z' 0x5A 0b01011010

'a' 0x61 0b01100001\
'z' 0x7A 0b01111010

* 3번째 비트만 반전
* 대소문자 변환을 비트연산으로 할 수 있다.

디버그 모드에서는 지역 변수를 cc로 밀어준다.
* 지역 변수 영역을 cc로 밀 뿐 실제 사용가능한 영역은 아니다.
* 문자열 처리 함수를 수행하면 fd로 민다.
* 릴리즈 빌드에서는 사라진다.

int a = 4;
* 실제로는 12바이트 공간을 할당한다.

1. cccccccc
2. 04000000
3. cccccccc

스택 카나리