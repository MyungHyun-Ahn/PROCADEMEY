# 프로카데미 Day02
## 01. 비트 연산자
* &
  * 마스킹한다.
  * 0b00101101
  * 0b00001111 : 마스킹한다.
* |
  * 비트를 합친다.
* ^
  * 같으면 0
  * a ^ b 를 한뒤 ^ b 를 하면 b가 복구가 된다.
  * ^ Key 값을 xor을 한뒤 다시 Key 값으로 xor하면 값이 복원 - xor 암호화
  * 이미지 처리
* ~
* <<
* \>\>
  * 과거에는 맵 크기 타일 픽셀 8x8, 16x16
  * 모든 좌표 계산을 나누기로 했었음
  * 나누기 대신 쉬프트를 많이 사용함
  * 지금은 그러지 않아도 된다.
  * 쉬프트를 쓰더라도 주석으로 * 몇인지 표시하자
  * unsigned라면 우측 끝 0인데
  * signed 변수라면 1이 들어옴
  * 무조건 비트연산 대상 변수는 unsigned 변수만 사용하자
  * 최상위 비트가 1일 때만 1로 채워진다.

비트연산 과제\
임의의 값을 넣고 바이너리 값을 출력\
비트의 위치를 입력\
입력한 비트의 위치만 변경\
위치(1~4) 4byte\
바이트 단위로 데이터를 입력하자

## 02. 삼항 연산자
* 빠르지 않다.
* 조건식 ? a : b

## 03. 캐스팅
* 컴파일러한테 해라~ 라고 지시하는 것
* 실질적으로 아무일 없다.

sizeof = 있는 그대로 숫자 치환\
컴파일 타임 치환

연산자 우선 순위\
외워라\
마이크로소프트 문서\
더하기, 곱하기, 나누기, 쉬프트\
비트연산자와 비교

### 연산자 우선 순위
그룹 1 우선 순위, 결합성 없음
* 범위 확인 : ::

그룹 2 우선 순위 (왼쪽에서 오른쪽 연결성)
* 멤버 선택(개체 또는 포인터) : . 또는 ->
* 배열 아래 첨자 : []
* 함수 호출 : ()
* 후위 증가/감소 : ++, --
* 형식 이름 : typeid
* C++ 캐스팅 : static_cast, dynamic_cast, reinterpret_cast, const_cast

그룹 3 우선 순위, 오른쪽에서 왼쪽 연결
* 개체 또는 형식의 크기 : sizeof
* 전위 증가/감소 : ++, --
* 보수 : ~
* 부정 : !
* 단항 부정 : -
* 단항 더하기 : +
* 주소 연산자 : &
* 간접 참조 : *
* 개체 생성, 삭제 : new / delete
* C 캐스팅 : ()

그룹 4 우선 순위 (왼쪽에서 오른쪽 연결성)
* 멤버에 대한 포인터 : .* 또는 ->*

그룹 5 우선 순위 (왼쪽에서 오른쪽 연결성)
* 곱하기 : *
* 나누기 : /
* 계수 : %

그룹 6 우선 순위 (왼쪽에서 오른쪽 결합성)
* 더하기 : +
* 빼기 : -

그룹 7 우선 순위 (왼쪽에서 오른쪽 결합성)
* 왼쪽 시프트 : <<
* 오른쪽 시프트 : >>

그룹 8 우선 순위 (왼쪽에서 오른쪽 결합성)
* 비교 연산자 : <, >, <=, >=

그룹 9 우선 순위 (왼쪽에서 오른쪽 연결성)
* 등호 : ==, !=

그룹 10 우선 순위 (왼쪽에서 오른쪽 결합성)
* 비트 AND : &

그룹 11 우선 순위 (왼쪽에서 오른쪽 연결성)
* 비트 XOR : ^

그룹 12 우선 순위 (왼쪽에서 오른쪽 결합성)
* 비트 OR : |

그룹 13 우선 순위 (왼쪽에서 오른쪽 결합성)
* 논리적 AND : &&

그룹 14 우선 순위 (왼쪽에서 오른쪽 연결성)
* 논리적 OR : ||

그룹 15 우선 순위 (오른쪽에서 왼쪽 결합성)
* 조건부 : ?:
* 양도 : = 
* 곱하기 할당 : *=
* 나누기 배정 : /=
* 모듈러스 할당 : %=
* 추가 할당 : +=
* 빼기 할당 : -=
* 왼쪽 시프트 할당 : <<=
* 오른쪽 시프트 할당 : >>=
* 비트 AND 할당 : &=
* 비트 포함 OR 할당 : |=
* 비트 XOR 할당 : ^=
* throw 식 : throw

그룹 16 우선 순위 (왼쪽에서 오른쪽 결합성)
* Comma : ,

### C와 C++의 다른점 1개
삼항연산자
* C++에서는 *= 들과 같은 우선순위
* p == 0 ? p += 1 : p += 2;
* C++에서는 OK
* C에서는 NO

## 04. do while
~~~C++
#define SHOW(X)     \
if (X != 0)         \
    printf("%d", X);

if (Flag)
    SHOW(X);  // 여기서 if문을 끝낸다.
else
    SHOW(X);
~~~

### 매크로를 만드는 정석적인 방법 do while(0)을 사용

~~~C++
#define SHOW(X)     \
do {                \
  if (X != 0)       \
  printf("%d", X);  \
} while (0)  // 여기서 do while 문의 ; 이 된다.

void Test()
{
int a = 10;
if (a != 10)
{
    // 정리코드
    return;
}
}

do                
{                 
    if ( a != 10) 
        break;
    // 정상코드...
} while (0);
~~~
* 여기서 goto 문을 쓰면 편한데..
  * goto는 기피하는 분위기
* 이럴 때 쓰는것이 do while(0);


### if문을 사용할 때 true에 걸리게 하면 안좋다. false 면 중단


## CPU 아키텍처
* 어셈블리 언어와 레지스터를 규약한 것
* x86 실제로 64비트 -> 32비트 아니다
* 일반적으로 서버를 만들면 서버 전용 아키텍처 CPU가 있다.
* x64 64비트
* 인텔 AMD 같은 아키텍처(x86)를 사용했기 때문에 호환이 되는 것
* x86은 LOAD STORE 명령어가 없다 mov 명령어
* x86엔 pc가 없고 ir이 있다.

## 함수 호출 규약
오른쪽에서 왼쪽
* Test(1, 2, 3); 3 -> 2 -> 1


Test()
* 1  이게 누구꺼?
* 2  Test껀 아님
* 3 메모리 위치로 따지면 중간에 껴있음

main()

* 함수를 호출할 때마다 스택 프레임을 확보함
* 인자는 중간에 끼게 됨

void Param()
{
    static int x = 0;
    x++;
    return;
}

Test(Param(), Param(), Param());

* cdecl : RTL, 스택 정리 규칙 - 호출자
* stdcall : RTL, 스택 정리 규칙 - 피호출자
* 마이크로소프트 x64 호출 규약 : 차후에


원래는 호출규약을 붙여야함\
프로젝트 속성 -> C/C++ -> 고급 -> 호출규약 default cdecl\
윈도우 API CALLBACK
* CALLBACK 의미 : 내가 만들었지만 내가 호출하지 않고 시스템에 등록하는 역할  
* 포인터를 등록해주세요 윈도우에서 알아서 할게요
* CALLBACK : __stdcall
* 이미 __stdcall로 만들어진 윈도우 함수에서 호출하기 때문

어셈블리에서는 16진수 맨뒤 h를 표기해서 표시

* __stdcall이 안되는 경우
* 가능하려면 함수의 선언부 정의부에서 파라미터가 명확해야 한다.
* 실제 리턴하는 부분에 파라미터 크기를 계산이 되서 나와야한다. 컴파일 시점에
* 가변 인자

어떤 호출규약을 쓰던 실제로 호출자와 피호출자만 지켜주면 된다.\
우연히 호출규약이 어긋나게 되면 스택이 밀려버림\
컴파일러가 알아서 해주긴 한다.

* fastcall : 더 빠르게 하기 위해서 스택의 사용을 줄이자
  * 파라미터를 그냥 레지스터에 넣는다. AX DX BX 순서대로

레지스터
* a b c d 8
* ax bx cx dx 16
* eax ebx ecx edx 32
* rcx rdx r8 r9 64

r8, r9 는 새로나온 레지스터

CPU를 만들 때 하위 호환을 고려해서 만듬\
* x64는 stdcall cdecl 없음, 무조건 x64 호출규약
* 레지스터 용량을 넘어가면 스택을 활용



