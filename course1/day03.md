# 프로카데미 day03
## 01. 함수
* 함수 호출하면 스택 시작 주소부터 위로 : 함수의 지역변수 저장소
* 실제로 코드는 코드 영역에서 도는 것
* 스택 영역 : 코드가 도는 동안에 임시로 저장할 영역
* PC (Program Counter) : 윈도우에서는 IP 레지스터 - CPU가 마냥 돌리기만 함

return Value
* eax에 리턴 값을 저장
* 함수가 끝나면 eax 값을 가져온다. 단, 레지스터에 담을 수 있는 크기만

xor eax, eax -> 어떤 값이던 0 : CPU 내부에서 끝나는 문제 - 훨씬 빠르다.

mov eax, [a]
* a 위치를 계산할 수 있는 주소

mov eax, 0
* 0은 어디에 있을까
* 코드 영역에 대놓고 0으로 있음

int Test(int x)\
{\
&nbsp;&nbsp;&nbsp;&nbsp;if(x == 1)\
&nbsp;&nbsp;&nbsp;&nbsp;return 10;\
&nbsp;&nbsp;&nbsp;&nbsp;printf(...);\
}

* 모든 경로에서 값을 반환하지는 않습니다.
* 매우 위험한 일

**eax에 있는 값을 그대로 반환하게 된다.**


서버 프로그래밍을 할 때는 어떠한 경고도 모두 제거한다.

빌드 후 경고가 사라짐? -> 코드가 수정이 되지 않았기 때문에 경고가 사라진 것이다.
* 완전 다시 빌드(rebuild on)하면 경고가 다시 나타난다. - 다시 띄워서 해결하자.

경고 수준이 날법한 것을 의도적으로 내는 경우도 있다.
* ex) 포인터 null
* 이럴 때는 경고를 끄는 코드를 넣자.

구조체를 return 하는 구조는 많이 다르다. -> 2코스 내용 어셈블리로 분석


## 02. 함수의 인자 전달 방법
call by value
* 구조체는 절대 안된다. (메모리 카피가 일어나기 때문)
call by reference
* 기본 타입은 절대 사용하지 말자
* 포인터 크기보다 객체가 작거나 같으면 call by value가 괜찮을 수 있다.
* long long 타입인 경우. reference가 더 나을 것 같은 느낌 -> 후에 확인하자.


const의 위치

const int *p = &a;\
int const *p = &a;
* const가 *에 붙은 것
* 포인터 내부의 값에 접근하지 못한다.
* *p = 10 -> 불가능

int * const p = &a;
* const가 변수에 붙은 것
* 변수 자체(주소값)을 바꾸지 못한다.

call by reference의 경우 
* const *을 무조건 사용하자.
* 읽기만하는 함수의 경우 뭔가를 변경하게 되면 문제가 생긴다.
* 인자를 *로 받을 경우에는 읽기만 할지, 쓰기도 할지 용도를 정해서 명확하게 사용하자.

## 03. 매크로
* #define : 매크로 정의
* #undef : 매크로 정의 해제 -> 나중에 쓸일이 있음, 알아두자
* #if, #indef ...


조건부 컴파일

#ifndef ABCD\
#define ABCD\
#endif

Visual Studio에서 #define이 자동으로 들어가는 경우
* C/C++ -> 전처리기 정의 : 이곳에 지정된 것들은 자동으로 추가가 된다.

Release 모드에서 하지 않을 것들은
* __DEBUG 정의를 하고 내부에 사용하자.

조건부 컴파일을 하는 경우
* 전세계 1개의 소스파일로 서비스 하는 경우 -> 언어설정
* 그 나라만의 특색을 넣을 때 -> 조건부 컴파일

단, 소스코드가 길어지면(MMO 같은 경우) 프로젝트가 여러개로 나뉠수도 있다.

C++ 업데이트를 하며 바뀐 것도 많다.
  
시스템 정의 매크로
* __FILE__ : 파일 매크로
* __LINE__ : 라인 수 읽기
* Log 만들 때 사용된다. 매우 유용

typedef : 타입을 재정의
* 언제쓰나? : 이름이 길 때
* 완전 정통 C에서는 struct를 무조건 붙여야 한다. - 이것을 쓰기 싫을 때

혹은 타입을 아예 재정의 해서 사용
* 프로젝트의 특성에 따라 다르다.

INT8\
INT16\
UINT8\
* 아예 비트를 명시해서 헷갈리지 말자는 의미
* 추가로, long 타입 같은 경우 컴파일러에 따라 용량이 다를 수도 있다.

windows api에서 타입을 재정의 하는 이유
* 모든 언어(C, C++, C#, .net 등)에서 호환을 맞추기 위해서
* 하위 버전 호환성을 위해

윈도우 ODBC : 데이터베이스와 연동하기 위한 마이크로소프트 라이브러리
* 모든 데이터베이스(MySql, MS-Sql 등)에 호환성을 위해
* 또한 언어도 중립적

## 04. enum 열거형
enum : type화 시킬 수 있다.

enum enATTACK_1\
{\
&nbsp;&nbsp;&nbsp;&nbsp;ATTACK_1 = 0\
}
\
\
\
enum enATTACK_1\
{\
&nbsp;&nbsp;&nbsp;&nbsp;ATTACK_1 = 0\
}

* ATTACK_1 이라는 이름은 C에서는 중복되게 사용하지 못한다.
* enum의 값이 전역적으로 풀리기 때문

enum을 선언하면
* skill(숫자) 와 같은 형식으로 호출하지 못한다.
* skill(무조건 enum 값)

C에서
* ATTACK_1 : 호출 가능
* enATTACK_1::ATTACK_1 : 호출 가능

C++에서
* ATTACK_1 : 호출 불가능
* enATTACK_1::ATTACK_1 : 호출 가능

서버와 클라 컨텐츠 몇 백개 패킷 종류 몇 백개
* 패킷마다 번호를 나눠서 처리
* 메시지 번호에 따라 대역을 나눈다. : ex 0-999 : 로그인

void *ptr;
* 모든 포인터 연산이 불가능
* 정말 포인터 보관 용도로 사용

NULL 포인터 -> Cpp 에서는 nullptr로 사용하자.

## 05. 함수 포인터
int A();
* 함수 포인터 : A
* 함수 콜 : A();

void (*ptr)();
* CALLBACK 함수 같은 경우 함수 포인터 사용

패킷 처리 시
* switch case
* 너무 패킷의 양이 많다면, 함수 포인터 배열을 만든다.

C에서 함수 포인터 배열 선언
* void (*ProcFunc[ARR_SIZE])(char* pBuf);
* 함수 포인터의 경우 소스코드만 보고 디버깅이 힘들어진다.
* 소스코드를 줄인다. : 난해하게 만든다.