# 프로카데미 Day01
## 01. 헝가리안 표기법
 - 변수명을 지을 때 맨 앞에 소문자로 자료형을 표기
 -  ex) dw, lp

## 02. 기본 자료형
### 02.1 기억 클래스
- auto : 모던 C++ 과 다른 것, 맘대로 해라, 전역은 데이터, 지역은 스택
- extern : 외부변수, 컴파일러에게 이 변수가 어딘가 있다고 알려줌
---
- register : CPU 안에 있는 레지스터 32bit, 64bit, 가능하다면 레지스터에 선언해주세요.
- 남는 레지스터가 있다면 해당 변수는 레지스터에 선언된다.
- 왜 레지스터를 거쳐야 하는가?
- 애초에 CPU는 RAM을 접근하지 못한다.
- RAM - 값 전달 - CPU
---
- static : 전역 static, 지역 static, 데이터 세그먼트
- 전역 static : 그 소스 파일 내부에서만 쓰라.
- a.cpp가 있고 b.cpp가 있다. - a.cpp 에서만 사용 가능함
- 용도가? C스타일 캡슐화 -> 함수를 만듬
- 전역변수를 static으로 선언하면 다른 소스에서 못 건드린다.
---
### 02.2 속성 수식자
- volatile : 최적화 컴파일을 의도적으로 막는 것
- 사용하는 경우, 변수가 사라질 수 있어 디버깅에 위험함
---
### 02.3 컴파일 모드
- Debug : 디버깅
- Release : 최적화 컴파일을 진행
- 실제 소스파일과 어셈블리 파일이 일치하지 않아 디버깅이 제대로 진행되지 않음.

## 03. 자료형의 크기
- 16bit 컴파일러 int 2byte
- 32bit 컴파일러 int 4byte
- 64bit 컴파일러 int 4byte
- 64비트 컴파일러 데이터 모델 : LLP64
- C# long - 8byte : C++ long - 4byte
- 2byte : 65535 - 암기

---

## 04. 음수
- 보수 : 자리 올림이 되게 보충해주는 수
- 10의 보수 : 5 - 5가 보수 : 10이 되게하는 수
- 5 - 3 : 5 + 7 = 2 + 1


### 04.1 2의 보수
- char a = -1
- 0xff : f = 1111
- 11111111
- 00000001 : 1
- 11111110 : 비트 반전
- 11111111 : + 1
- 0xa7
- 10100111 : 맨 앞 비트 - 보수
- 컴퓨터는 보수인지 뭔지 신경 안 쓰고 그냥 더한다.
- 그냥 다 더하기

---

10100111
76543210
128 32 4 2 1
167

01011000
01011001
64 16 8 1
-89

---
## 05. 변수의 선언
- 지역 변수에는 선언이라는 행위 자체가 없다.
- 지역 변수는 할당이라는 개념 자체가 없다.
- 옛날 C 스타일 - 모든 선언을 맨 상단부에 한다.
- 컴파일러가 편하라고 하는 행위
- 선언 : 이 함수에서 공간을 얼마나 쓸지 합산이 필요
- 스택에 사용할 사용부 만큼 push
- 변수의 생명주기와는 관계없이 함수가 생성되고 삭제될 때까지 데이타는 유지된다.
- 언어적인 접근, 시스템적인 접근이 다르다.
- 두 관점 모두 공부해야 한다.
- 변수를 절대 , 콤마로 나열하면 안 된다. - 무조건 가독성이 중요
- int* p2, p3, p4; 일 때 p3, p4는 포인터 변수가 아니게 된다.
- int *p5; *는 p5에 붙은 것이다.

## 06. 연산자
- 전위++ 후위++ : 단순히 더하는 경우
- 객체일 때는 복사 비용이 들어가는 것이 맞다. - 어셈블리를 건들 수 없으므로
- iterator 일 때는 전위 ++ 후위 ++이 다르다. - 객체이기 때문
- 일반 변수일 때는 똑같다.
- int x = a++; 인 경우, 연산의 순서가 다르다.
- 인터넷은 오개념이 많다. 직접 보고 확인해봐야 한다.