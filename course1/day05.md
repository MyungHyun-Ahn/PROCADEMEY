# day 05

const char *p = "abcd";
* abcd 문자는 어디서 오는가?
* char *p = "abcd"; 로 받으면 오류다. 과거에는 아니었다.
* 코드 영역과 거의 동급인 데이터 영역의 .rodata 영역

char *p2 = (char *)p;\
p2[0] = 'b';
* 프로그램 크래시, .rodata(read-only) 영역에 접근

## 구조체
연관있는 것들을 묶어놓겠다.

### 구조체 패딩
* 구조체를 생성하면 실제 크기보다 더 크게 나온다.
* 패딩 바이트가 끼었기 때문
* 구조체만 해당은 아니고, 모든 변수에 적용된다.
* 지역 변수, 전역 변수 등 모든 변수의 규칙이다.

가장 큰 변수에 맞춘다는 것은 맞춘다는 아니다.
* 구조체 전체 크기 기준

struct stData\
{\
char a;\
short b;\
int c;\
short d;\
char e;\
short f;\
int g;\
}
* 0 char a : 1 + 1 Padding
* 2 short b : 2 + 2 Padding
* 4 int c : 4
* 8 short d : 2
* 10 char e : 1 + 1 Padding
* 12 short f : 2 + 2 Padding
* 16 int g : 4
* 총 크기 20바이트

왜 하는가?
* CPU가 읽기 편하게 바이트에 경계를 지정하는 것
* 가상 메모리의 시작 주소를 1, 2, 4, 8 에 나누어 떨어지는 숫자에 둔다.

컴파일러가 규칙을 구조체의 시작은 0이라고 잡고 계산\
무조건 컴파일러는 전제로 시작 주소가 0이라고 하고 시작


만약 4의 경계라면?
* 4 단위로 나누어 떨어지는 주소가 시작 위치가 된다.
* 가장 큰 변수 기준으로 경계가 정해진다.

구조체 안의 구조체
* 구조체를 까고 본다.
* 구조체 안에서 나뉘어진다.

CPU 입장에서 저렇게 해주어야 최적의 성능을 낼 수 있다.
* class도 마찬가지

C/C++ -> 코드 생성 -> 구조체 멤버 변수 경계값
* 1바이트 : 패딩 없어짐
* 2바이트 : int 부터 영향
* 4바이트 : 8바이트 자료형부터 영향

경계에 서지 않으면 로드할 때 잘라서 읽는다.


네트워크 프로토콜 통신의 경우 -> 구조체 단위 -> 바이트 변환
* 하나의 덩어리로 보고 통신한다.

게임에서 가장 비싼 비용
1. 인건비 : 가장 비싸다.
2. 트래픽 : 트래픽이 많으면 비쌈
3. 하드웨어, 소프트웨어 유지비 : 별로 안비싸다.


패딩?
* 컴파일러가 개입한 것
* 코드에는 없다. -> 컴파일러가 만듬
* 다른 컴파일러는 다를수도 있다.

네트워크 메시지 프로토콜
* 패딩을 1로 둔다.
* 의도한 바이트 순서를 맞춘다.
* 트래픽 비용을 줄이기 위해
* 약간의 성능은 포기한다.

왜 단위로 맞출까?
* 구조체 배열을 고려, 뒤 경계도 포함

#pragma pack(push, 1)\
// 구조체 정의\
#pragma pack(pop)
* push 지점부터 패딩을 1로 맞춘다.
* pop을 무조건 해준다. 안하면 뒤의 모든 소스코드에 있는 것이 전부 1로 맞추어 진다.

위 구문은 메시지를 보내기 직전에만 쓴다.
* 활용하는 순간이 매우 적다.

지역 변수나 동적 할당도 결과가 같아야 한다.
* 지역 변수는 기본 타입에 대해 무조건 맞는다.
* 32bit 4단위
* 64bit 8단위

동적 할당의 경우
* 컴파일러는 마냥 주기만 할뿐

패딩 규칙대로 그냥 더한다.
* 기본 맞춤은 8바이트
* 64비트 16 바이트
* 힙 버킷의 최소 단위이다.


포인터를 조작하지 않으면 문제가 안생긴다.\
메모리 관리자, 메모리 풀, 용량을 계산하여 데이터를 채우는 경우
* 예상하지 못한 상황이 나올 수 있다.

경계가 무너졌을 때 오작동?
* 인텔 계열의 CPU는 내부에 버퍼를 둔다. - 거기에 있으면 빠르게 읽는다는 것 - 캐시 히트
* RAM에서는 4바이트를 읽지 않는다.
* 캐시라인이라고 부르는 단위인 64바이트 씩 읽는다.
* 주변에 있는 데이터를 쓸 확률이 높다는 캐시 교체 정책

만약 데이터가 경계에 걸치게 된다면?
* 멀티 스레드 상황
* [ a/2][a/2 ] : 반씩 캐시라인에서 쪼개진 상황
* 한 스레드에서는 b = a;
* 그리고 다른 스레드에서 a = X; a = Y; 로 값을 교체
* 절반 씩 섞인 값을 얻어올 수도 있다.

구조체에서 실질적인 c 오프셋을 읽어오는 법
* int offset = (int)(&(((stData*)NULL)->c));
* (0 + c) 컴파일러가 오프셋을 구하는 방법
* 모던 C++에서는 offsetof라는 매크로가 추가되었다.

구조체 접근 중 첫번째 멤버의 접근이 가장 빠르다.
* 많이 사용하는 변수는 첫번째로

구조체 Int, Char, Short
* 3개가 안에 있는 경우, int가 가장 크므로 결국 4바이트 경계에 선다.
* 안까지 보고 가장 큰 변수타입이 경계

패딩 설정 키워드
* __declspec(align(16)) : 최대값 8192, 임의로 경계를 맞추는 것, C++ 표준이 아님
* alignas(16) : C++ 표준 : 나중에 캐시 공부하고 쓸 일이 있다.

경계의 배수로 할당받는 malloc
* _aligned_malloc(size_t size, size_t alignment);
* _aligned_free